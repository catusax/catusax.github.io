<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Just4fun</title>
  
  
  <link href="https://coolrc.me/atom.xml" rel="self"/>
  
  <link href="https://coolrc.me/"/>
  <updated>2021-09-05T18:23:58.000Z</updated>
  <id>https://coolrc.me/</id>
  
  <author>
    <name>coolrc</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从docker迁移到podman，支持docker-compose</title>
    <link href="https://coolrc.me/2021/09/05/202109051825/"/>
    <id>https://coolrc.me/2021/09/05/202109051825/</id>
    <published>2021-09-05T18:23:58.000Z</published>
    <updated>2021-09-05T18:23:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>docker.io最近取消了免费的自动构建功能，而且docker.io的镜像拉取也有限制。但是docker的默认registry只能是docker.io。如果要拉取gcr.io的镜像，还得先拉下来镜像上的，再修改tag，非常麻烦，而用podman的话，直接配置一个registry镜像就可以</p><span id="more"></span><p>以前使用podman的时候，总是会遇到一个问题，就是docker-compose没法用，而podman-compose的功能实在是太少。好在现在podman 3.0发布以后，已经可以无缝衔接docker-compose了。</p><h2 id="卸载docker"><a href="#卸载docker" class="headerlink" title="卸载docker"></a>卸载docker</h2><p>直接卸载docker-ce就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove docker-ce</span><br></pre></td></tr></table></figure><p>docker的镜像存储和podman，containerd都是不兼容的，所以本地的镜像也可以删了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /var/lib/docker /etc/docker</span><br><span class="line">sudo rm /etc/apparmor.d/docker</span><br><span class="line">sudo rm -rf /var/run/docker.sock</span><br><span class="line">sudo groupdel docker</span><br></pre></td></tr></table></figure><h2 id="切换到podman"><a href="#切换到podman" class="headerlink" title="切换到podman"></a>切换到podman</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install podman</span><br></pre></td></tr></table></figure><p>要让docker-compose能够访问到podman，需要启动podman服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable podman.socket</span><br><span class="line">sudo systemctl start podman.socket</span><br><span class="line">sudo systemctl status podman.socket</span><br><span class="line">sudo curl -H &quot;Content-Type: application/json&quot; --unix-socket /var/run/podman/podman.sock http://localhost/_ping</span><br></pre></td></tr></table></figure><p>然后就能在docker-compose里指定socket地址来使用了</p><p>在shell配置里加入如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=unix:///var/run/podman/podman.sock</span><br><span class="line">alias docker=podman</span><br></pre></td></tr></table></figure><p>然后就能无缝使用docker-compose了。这里加alias的作用是，虽然docker-compose是直接连接docker的api的，但是有时候会直接执行docker命令,加上这个才能保证一定不会出错。</p><h2 id="使用非root模式"><a href="#使用非root模式" class="headerlink" title="使用非root模式"></a>使用非root模式</h2><p>上面的方法是以root权限启动podman的，这样导致podman最大的优点非root运行没有了，3.2.0版本后，我们还可以用非root模式来启动podman服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl --user enable podman.socket</span><br><span class="line">systemctl --user start podman.socket</span><br><span class="line">systemctl --user status podman.socket</span><br></pre></td></tr></table></figure><p>shell配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=///run/user/$UID/podman/podman.sock</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://fedoramagazine.org/use-docker-compose-with-podman-to-orchestrate-containers-on-fedora/">Use Docker Compose with Podman to Orchestrate Containers on Fedora Linux</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;docker.io最近取消了免费的自动构建功能，而且docker.io的镜像拉取也有限制。但是docker的默认registry只能是docker.io。如果要拉取gcr.io的镜像，还得先拉下来镜像上的，再修改tag，非常麻烦，而用podman的话，直接配置一个registry镜像就可以&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>golang中令人迷惑的切片与函数参数传递</title>
    <link href="https://coolrc.me/2021/08/03/202108031930/"/>
    <id>https://coolrc.me/2021/08/03/202108031930/</id>
    <published>2021-08-03T19:29:49.000Z</published>
    <updated>2021-08-03T19:29:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究下切片作为函数参数时到底发生了什么</p><span id="more"></span><h2 id="简单测试一下"><a href="#简单测试一下" class="headerlink" title="简单测试一下"></a>简单测试一下</h2><p>先用一个数组试一下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">changeSlice(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(slice [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>看来数组是拷贝的</p><h3 id="把数组变成切片"><a href="#把数组变成切片" class="headerlink" title="把数组变成切片"></a>把数组变成切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">changeslice(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeslice</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out </span></span><br><span class="line"><span class="comment">// [1 2 333 4 5]</span></span><br></pre></td></tr></table></figure><p>数组被改变了，这说明切片是引用传递的。</p><h2 id="事情没那么简单"><a href="#事情没那么简单" class="headerlink" title="事情没那么简单"></a>事情没那么简单</h2><p>那么问题来了，既然切片都能按引用传递，那怎么数组还是按照值传递的呢？</p><p>再来试一下这个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">    b := a[:]</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,&amp;b)</span><br><span class="line">changeSlice(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%p&quot;</span>,&amp;slice)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// 0xc00000c3f0</span></span><br><span class="line"><span class="comment">// 0xc000004078</span></span><br></pre></td></tr></table></figure><p>数组的地址和指针的地址不一样啊。怎么回事？</p><p>这是因为切片和数组的构造其实完全不一样，切片其实是一个包含数组信息的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SliceHeader is the runtime representation of a slice.</span></span><br><span class="line"><span class="comment">// It cannot be used safely or portably and its representation may</span></span><br><span class="line"><span class="comment">// change in a later release.</span></span><br><span class="line"><span class="comment">// Moreover, the Data field is not sufficient to guarantee the data</span></span><br><span class="line"><span class="comment">// it references will not be garbage collected, so programs must keep</span></span><br><span class="line"><span class="comment">// a separate, correctly typed pointer to the underlying data.</span></span><br><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片里面包含数组位置，切片长度和切片容量(数组大小)，所以我们可以解释刚才的参数传递行为：</p><p>golang其实就是完全值传递的，只不过由于切片的特殊结构，里面保存了原数组的指针，所以我们才能在函数内修改原数组。</p><p>同时这也解释了另外一个问题：为什么对切片<code>append()</code>需要用返回值覆盖原来切片？因为append之后切片内部的容量和长度信息变了,而golang为我们隐藏了切片的内部实现，所以我们不能像Java的List那样使用一个对象和属性来变更信息，只能覆盖原切片。</p><p>下面再看一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">changeSlice(a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">6</span>)</span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure><p>对切片进行了扩容，再改变切片的话，原来的切片还是没变。这是因为我们原来的切片来自一个长度只有5的数组，所以切片的容量就是数组的长度，想要扩容就只能复制原来的数组了</p><p>扩容两次再试试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">6</span>)</span><br><span class="line">slice[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">fmt.Println(slice)</span><br><span class="line">slice2 :=<span class="built_in">append</span>(slice,<span class="number">6</span>)</span><br><span class="line">slice2[<span class="number">2</span>] = <span class="number">3344</span></span><br><span class="line">fmt.Println(slice)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out </span></span><br><span class="line"><span class="comment">// [1 2 333 4 5 6]</span></span><br><span class="line"><span class="comment">// [1 2 3344 4 5 6]</span></span><br></pre></td></tr></table></figure><p>可以看到，第二次扩容后，slice2的改变能影响到slice1。因为切片第一次扩容后并不是简单的增加了一位。如果，每次append都只+1的话，那岂不是效率很慢，而且会占用很多内存空间。所以golang对切片扩容有其他的规律。具体请看参考资料。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">6</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">slice = <span class="built_in">append</span>(slice,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>如上，每次扩容切片容量翻倍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以切片到底是”传值”还是”传引用”，完全要看你对切片的操作有没有导致扩容。</p><p>如果真的要再一个函数里面操作切片的话，不希望改变原切片，可以使用copy(a，b)拷贝一下。</p><p>如果希望改变原切片，要么保证你的操作不会引起扩容，要么可以使用闭包。如果以上两个都不行，也可以选择传递指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用指针修复扩容导致的切片引用失效</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">changeSlice(&amp;a)</span><br><span class="line">fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(slice *[]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">*slice = <span class="built_in">append</span>(*slice,<span class="number">6</span>)</span><br><span class="line">(*slice)[<span class="number">2</span>] = <span class="number">333</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="comment">// [1 2 333 4 5 6]</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/">https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究下切片作为函数参数时到底发生了什么&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Spring Data多数据源冲突问题</title>
    <link href="https://coolrc.me/2021/08/01/202108011240/"/>
    <id>https://coolrc.me/2021/08/01/202108011240/</id>
    <published>2021-08-01T12:37:59.000Z</published>
    <updated>2021-08-01T12:37:59.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="不同数据源冲突"><a href="#不同数据源冲突" class="headerlink" title="不同数据源冲突"></a>不同数据源冲突</h2><p>在spring里面配置了两个以上数据源的时候，可能会出现报错，例如我配置了ES和Mongo两个数据源，就会这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The bean &#x27;xxxxEsRepository&#x27;, defined in xx.repositories.xxEsRepository defined in @EnableMongoRepositories declared on xxApplication, could not be registered. A bean with that name has already been defined in me.xxx.repositories.xxxEsRepository defined in @EnableElasticsearchRepositories declared on xxApplication and overriding is disabled.</span><br></pre></td></tr></table></figure><p>一段报错里出现了<code>@EnableMongoRepositories</code>和<code>@EnableElasticsearchRepositories</code>两个注解，意思就是Repository的bean冲突了。</p><p>由于我们的<code>@EnableElasticsearchRepositories</code>写在前面，所以所有标注了<code>@@Repository</code>的都被作为ES的repo注入了，接下来<code>@EnableMongoRepositories</code>还会再做同样的事情，每个bean都被注册了两次，就冲突了。</p><p>这个时候，就要我们手动来指定哪个配置对应哪个repo了，手动指定两个配置对应的repo就行了。</p><p>原来的@Enable注解修改一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="meta">@EnableElasticsearchRepositories(</span></span><br><span class="line"><span class="meta">    includeFilters = [ComponentScan.Filter(type = FilterType.REGEX, pattern = [&quot;.*EsRepository&quot;])]</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(</span></span><br><span class="line"><span class="meta">    includeFilters = [ComponentScan.Filter(type = FilterType.REGEX, pattern = [&quot;.*MongoRepository&quot;])])</span></span><br></pre></td></tr></table></figure><p>只要加一个includeFilters，指定你要用哪个repo的类就行了，当然，你也可以用<code>excludeFilters</code>排除不相干的类。这里用<code>basePackageClasses</code>没有用，暂时不知道为啥。</p><h2 id="同一个数据源不同数据库"><a href="#同一个数据源不同数据库" class="headerlink" title="同一个数据源不同数据库"></a>同一个数据源不同数据库</h2><p>还有另外一种常见操作是，在同一个数据源里面我们要请求不同的数据库，或者不同服务器。这个时候还是类似上面的操作。</p><p>因为有两个Configuration，所以要注解两次，这时候优先使用Java配置：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(<span class="meta-string">&quot;primary&quot;</span>)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackageClasses = [ChatMessageMongoRepository::class],</span></span><br><span class="line"><span class="meta">    basePackages = [<span class="meta-string">&quot;me.coolrc.chatlog.repositories.mongo.chat_message&quot;</span>],</span></span><br><span class="line"><span class="meta">    mongoTemplateRef = <span class="meta-string">&quot;primary-template&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoConfigPrimary</span> : <span class="type">AbstractMongoClientConfiguration</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">&quot;primary-database&quot;</span>)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix=<span class="meta-string">&quot;spring.database&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDatabaseName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;chatlog&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">&quot;primary-template&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mongoTemplate</span><span class="params">(databaseFactory: <span class="type">MongoDatabaseFactory</span>, converter: <span class="type">MappingMongoConverter</span>)</span></span>: MongoTemplate &#123;</span><br><span class="line">        <span class="keyword">return</span> MongoTemplate(mongoClient(),databaseName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">&quot;primary-client&quot;</span>)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix=<span class="meta-string">&quot;spring.client&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mongoClient</span><span class="params">()</span></span>: MongoClient &#123;</span><br><span class="line">        <span class="keyword">return</span> MongoClients.create(<span class="string">&quot;mongodb://root:example@localhost:27017&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration(<span class="meta-string">&quot;second&quot;</span>)</span></span><br><span class="line"><span class="meta">@EnableMongoRepositories(basePackageClasses = [UserMongoRepository::class],</span></span><br><span class="line"><span class="meta">    basePackages = [<span class="meta-string">&quot;me.coolrc.chatlog.repositories.mongo.user&quot;</span>],</span></span><br><span class="line"><span class="meta">    mongoTemplateRef = <span class="meta-string">&quot;second-template&quot;</span></span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="comment">//@EnableMongoRepositories(includeFilters = [ComponentScan.Filter(type = FilterType.REGEX, pattern = [&quot;.*UserMongoRepository&quot;])])</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MongoConfigSecond</span> : <span class="type">AbstractMongoClientConfiguration</span></span>() &#123;</span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">&quot;second-database&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getDatabaseName</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;not_exist&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">&quot;second-template&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mongoTemplate</span><span class="params">(databaseFactory: <span class="type">MongoDatabaseFactory</span>, converter: <span class="type">MappingMongoConverter</span>)</span></span>: MongoTemplate &#123;</span><br><span class="line">        <span class="keyword">return</span> MongoTemplate(mongoClient(),databaseName)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(<span class="meta-string">&quot;second-client&quot;</span>)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">mongoClient</span><span class="params">()</span></span>: MongoClient &#123;</span><br><span class="line">        <span class="keyword">return</span> MongoClients.create(<span class="string">&quot;mongodb://root:example@localhost:27017&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是用注解指定我们要scan的包或者类，注入对应repo，但是光这样还不够。</p><p>我们还要手动绑定<code>TemplateRef</code>，然后需要自己实现<code>mongoTemplate</code>。这是因为虽然我们只指定scan后，两个config注入对应的repo了，但是<code>databaseFactory</code>这个bean其实只有一个，生成的<code>mongoTemplate</code>也就只有一个。</p><p>所以我们要忽略掉<code>databaseFactory</code>，自己实现<code>mongoTemplate()</code>,手动new一个<code>mongoTemplate</code>。当然，你也可以实现<code>mongoDbFactory()</code>都是一样的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h2 id=&quot;不同数据源冲突&quot;&gt;&lt;a href=&quot;#不同数据源冲突&quot; class=&quot;headerlink&quot; title=&quot;不同数据源冲突&quot;&gt;&lt;/a&gt;不同数据源冲突&lt;/h2&gt;&lt;p&gt;在spring里面配置了两个以上数据源的时候，可能</summary>
      
    
    
    
    
    <category term="java" scheme="https://coolrc.me/tags/java/"/>
    
    <category term="kotlin" scheme="https://coolrc.me/tags/kotlin/"/>
    
    <category term="spring" scheme="https://coolrc.me/tags/spring/"/>
    
    <category term="mongo" scheme="https://coolrc.me/tags/mongo/"/>
    
  </entry>
  
  <entry>
    <title>几种排序算法的复杂度分析</title>
    <link href="https://coolrc.me/2021/07/31/202107311432/"/>
    <id>https://coolrc.me/2021/07/31/202107311432/</id>
    <published>2021-07-31T14:30:00.000Z</published>
    <updated>2021-07-31T14:30:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>对常见的排序算法复杂度的分析。</p><span id="more"></span><blockquote><p>关于排序算法的原理与实现直接看这里：<a href="https://github.com/hustcc/JS-Sorting-Algorithm">https://github.com/hustcc/JS-Sorting-Algorithm</a></p></blockquote><h2 id="几种简单的算法"><a href="#几种简单的算法" class="headerlink" title="几种简单的算法"></a>几种简单的算法</h2><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>每次将当前数字向前移动，直到插入到前面合适的位置。</p><ul><li><p>最好情况是数组已经排序好，不需要插入，只需要比较n次，时间复杂度O(n)</p></li><li><p>最坏情况是逆序，每次都把当前数字插入到最前面，需要n+(n-1)+… 1 次交换操作,时间复杂度O(n^2)</p></li></ul><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>冒泡排序是两两比较相邻元素，这样每次都把最小元素放到最前面，最大元素放后面。</p><ul><li><p>当数组排序好时候，只进行比较而不交换，时间复杂度O(n^2)，如果进行优化，增加一个标志位，第一次循环没有交换就直接退出，则时间复杂度可以减小到O(n)</p></li><li><p>最坏情况也是逆序，执行n+(n-1)+…1 次交换操作，时间复杂度O(n^2)</p></li></ul><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>最简单的一种，每次都把最小的数字取出来，存到排序的起始位置。不论是什么情况，都需要进行n+(n-1)+…2次比较，时间复杂度O(n^2)</p><h3 id="平均复杂度"><a href="#平均复杂度" class="headerlink" title="平均复杂度"></a>平均复杂度</h3><p>上面这些排序方法，都有一个共同点，就是每次从最小的序列开始排序，逐渐增加这个序列直到排序完成。这些算法每次都最多只能消除一个逆序。更进一步观察发现，这些算法实质都是每次交换相邻的两个元素来排序：</p><ul><li><p>插入排序每次交换相邻元素，直到当前数字小于插入数字</p></li><li><p>冒泡排序不用多说</p></li><li><p>选择排序对临时数字的比较也相当于交换相邻的元素，类似于冒泡排序</p></li></ul><p>要计算平均复杂度，只需要知道数组平均有多少逆序就行。对于N个互异数字的数组L，两两组合一共有N(N-1)种组合，这些组合有逆序也有正序。我们创造L的反序Lr，那么Lr数组中的逆序=L数组的正序数量。于是这两个数组一共有N(N-1)*2个序列，其中一半是逆序，也就是N(N-1)/2。因此可证明平均每个数组的逆序数量是N(N-1)/4。</p><p>上述算法每次只能最多消除一个逆序，因而平均时间复杂度为O(n^2)。</p><h2 id="冲破二次屏障的算法"><a href="#冲破二次屏障的算法" class="headerlink" title="冲破二次屏障的算法"></a>冲破二次屏障的算法</h2><p>上面的推论高速我们，如果一个算法每次只能两两交换删除一个逆序，那么平均时间复杂度最快只能是O(n^2)。为了打破这一规律，需要对相距较远的元素进行比较。</p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>将数组分为许多序列，每次对序列首尾进行交换，然后逐步缩小序列长度。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>使用归并操作每次归并小数组。</p><p>每次两两合并，一共合并logn次就能合并完，每次合并比较n次，所以任何情况都是O(nlogn)</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>使用分治法，将数组按照某个基准分为两个小数组排序。</p><p>由于使用了分治法，每次操作区间/2,最短要分logn次才能分到最短（每次都从中间分开），平均每次都是操作N个数字，所以最好情况的复杂度是O(nlogn)</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>利用堆的性质，把数组建成一个堆，然后每次取出堆顶部元素到另一个数组，最后拷贝回来。<br>堆的高度是log(n),所以每次取出需要</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p>这几个算法的时间复杂度都很难计算。但是已知他们的平均时间复杂度都是O(nlogn)。对于普通的比较排序方法，这是最快的平均时间复杂度。</p><p>如果有一个长为N的序列L，那么总共有N!种排列。这些排列中只有一种是有序的。将所有排列组成一个决策树，由于比较只有两种可能(&gt;=  &lt;,&gt; &lt;=  &gt;都是两种)所以这是一个二叉树。所有的排列都在叶子节点上，一共有N！个叶子节点。那么我们的决策树平均深度至少就是log(N!)。我们的算法就需要至少log(N!)次判断才能得出结果。<br>计算log(N!)，最后结果是 N/2*logN - N/2。也就是O(NlogN)</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对常见的排序算法复杂度的分析。&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="https://coolrc.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>简单对比Java和Kotlin反射性能</title>
    <link href="https://coolrc.me/2021/07/29/202107291739/"/>
    <id>https://coolrc.me/2021/07/29/202107291739/</id>
    <published>2021-07-29T17:38:54.000Z</published>
    <updated>2021-07-29T17:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2021/07/29/202107291536/">上篇文章</a>说了kotlin里面的反射。<br>既然Java和kotlin的反射包都能在kotlin里面用，虽然kotlin提供了更多操作，但是Java的用起来比较熟悉，那么到底选哪个呢，这次就跑个分试试性能。</p><span id="more"></span><h2 id="对比性能"><a href="#对比性能" class="headerlink" title="对比性能"></a>对比性能</h2><p>还是之前的注解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试注解</span></span><br><span class="line"><span class="meta">@MustBeDocumented</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.PROPERTY,AnnotationTarget.PROPERTY_SETTER,AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnno</span></span>(<span class="keyword">val</span> value:String=<span class="string">&quot;haha&quot;</span>)</span><br></pre></td></tr></table></figure><p>反射类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reflect</span><span class="params">(myAnno: <span class="type">Any</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> cls = myAnno::<span class="class"><span class="keyword">class</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有字段</span></span><br><span class="line">    <span class="keyword">val</span> fields = cls.declaredMemberProperties</span><br><span class="line">    <span class="keyword">for</span> (field <span class="keyword">in</span> fields)&#123;</span><br><span class="line">        <span class="comment">//直接修改字段</span></span><br><span class="line">        <span class="keyword">val</span> anno = field.findAnnotation&lt;MyAnno&gt;()</span><br><span class="line">        <span class="keyword">if</span> (anno != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="keyword">val</span> mutfield = field <span class="keyword">as</span> KMutableProperty1&lt;Any,Any&gt;</span><br><span class="line">            mutfield.isAccessible = <span class="literal">true</span></span><br><span class="line">            mutfield.<span class="keyword">set</span>(myAnno,anno.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用set方法</span></span><br><span class="line">    <span class="keyword">val</span> funcs = cls.functions</span><br><span class="line">    <span class="keyword">for</span> (func <span class="keyword">in</span> funcs)&#123;</span><br><span class="line">        <span class="keyword">val</span> anno = func.findAnnotation&lt;MyAnno&gt;()</span><br><span class="line">        <span class="keyword">if</span> (anno !=<span class="literal">null</span>)&#123;</span><br><span class="line">            func.call(myAnno,anno.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个都是这个逻辑，检查所有属性/字段和方法。</p><h3 id="修改Propertie和Field"><a href="#修改Propertie和Field" class="headerlink" title="修改Propertie和Field"></a>修改Propertie和Field</h3><p>我们先只修改一个字段，修改一亿次试试耗时：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span></span>()&#123;</span><br><span class="line">    <span class="meta">@MyAnno(<span class="meta-string">&quot;testtttttt&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AnnoTest(name=&#x27;<span class="variable">$name</span>&#x27;)&quot;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先跑下Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    AnnoTest annotest = <span class="keyword">new</span> AnnoTest();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">        reflect(annotest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis()-start;</span><br><span class="line">    System.out.println(annotest);</span><br><span class="line">    System.out.println(time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out </span></span><br><span class="line">AnnoTest&#123;name=<span class="string">&#x27;testtttttt&#x27;</span>&#125;</span><br><span class="line"><span class="number">41898</span></span><br></pre></td></tr></table></figure><p>用时41秒</p><p>再看Kotlin：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> annoTest = AnnoTest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeInMillis = measureTimeMillis &#123; <span class="comment">//这写法比Java方便一万倍有没有</span></span><br><span class="line">        <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.100000000</span>)&#123;</span><br><span class="line">            reflect(annoTest)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(annoTest)</span><br><span class="line">    println(timeInMillis)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line">AnnoTest(name=<span class="string">&#x27;testtttttt&#x27;</span>)</span><br><span class="line"><span class="number">20885</span></span><br></pre></td></tr></table></figure><p>比Java快了将近一倍！！！</p><h3 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h3><p>这次改成执行一个set方法试试</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span></span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mail:String=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnno(<span class="meta-string">&quot;testtttttt2222&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setMail</span><span class="params">(mail: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mail=mail</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AnnoTest(mail=&#x27;<span class="variable">$mail</span>&#x27;)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line">AnnoTest(mail=&#x27;testtttttt2222&#x27;)</span><br><span class="line">29796</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line">AnnoTest&#123;mail=&#x27;testtttttt2222&#x27;&#125;</span><br><span class="line">46908</span><br></pre></td></tr></table></figure><p>毫无悬念</p><h3 id="首次运行速度"><a href="#首次运行速度" class="headerlink" title="首次运行速度"></a>首次运行速度</h3><p>之前都是对一个对象反复操作，这次试试每次换个对象,还是注解一个set方法，这次跑1次</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> = runBlocking &#123;</span><br><span class="line">   <span class="keyword">val</span> annoTest = AnnoTest()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> timeInMillis = measureTimeMillis &#123;</span><br><span class="line">        reflect(annoTest)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    println(timeInMillis)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="number">373</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnoTest annotest = <span class="keyword">new</span> AnnoTest();</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    reflect(annotest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> time = System.currentTimeMillis()-start;</span><br><span class="line">    System.out.println(time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure><p>好吧，这次看来是Java赢了。这么看来，初次加载时候，Java比Kotlin快了很对，但是当反射次数多了以后，还是kotloin的后续运行速度会更快。</p><p>这主要是因为kotlin的反射依赖于<code>@Metadata</code>这个注解，kotlin每次反射时都要解析一下这个注解，所以才会造成初次加载慢了很多。<br>所以我们在用的时候，如果很注意初次加载性能，也不需要kotlin额外的反射特性，就可以用Java的反射包，其他时候还是乖乖用人家官方提供的反射包吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.kotlincn.net/docs/reference/reflection.html">Kotlin语言中文站</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/2021/07/29/202107291536/&quot;&gt;上篇文章&lt;/a&gt;说了kotlin里面的反射。&lt;br&gt;既然Java和kotlin的反射包都能在kotlin里面用，虽然kotlin提供了更多操作，但是Java的用起来比较熟悉，那么到底选哪个呢，这次就跑个分试试性能。&lt;/p&gt;</summary>
    
    
    
    
    <category term="kotlin" scheme="https://coolrc.me/tags/kotlin/"/>
    
    <category term="Java" scheme="https://coolrc.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>继续研究下kotlin的注解和反射</title>
    <link href="https://coolrc.me/2021/07/29/202107291536/"/>
    <id>https://coolrc.me/2021/07/29/202107291536/</id>
    <published>2021-07-29T15:35:56.000Z</published>
    <updated>2021-07-29T15:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2021/07/28/202107282228/">上一篇文章</a>已经介绍了java的注解和反射，这篇文章来看看kotlin里面的注解和反射。</p><span id="more"></span><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>kotlin立面定义注解的语法和Java略有不同，不过基本上还是差不多的。<br>先看上篇文章的那个Java版本注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD,FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用idea把他自动转换成kotlin代码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义注解</span></span><br><span class="line"><span class="meta">@MustBeDocumented</span></span><br><span class="line"><span class="meta">@Target(</span></span><br><span class="line"><span class="meta">    AnnotationTarget.FUNCTION,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.PROPERTY_GETTER,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.PROPERTY_SETTER,</span></span><br><span class="line"><span class="meta">    AnnotationTarget.FIELD</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnno</span></span>(<span class="keyword">val</span> value: String = <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>kotlin同样是四个元注解：</p><blockquote><ul><li>@Target 指定可以用该注解标注的元素的可能的类型（类、函数、属性、表达式等）；</li><li>@Retention 指定该注解是否存储在编译后的 class 文件中，以及它在运行时能否通过反射可见 （默认都是 true）；</li><li>@Repeatable 允许在单个元素上多次使用相同的该注解；</li><li>@MustBeDocumented 指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中。</li></ul></blockquote><p><code>@Target</code>增加了<code>PROPERTY_GETTER</code>和<code>PROPERTY_SETTER</code>，kotlin里面这些分的更细了，而且多个参数不需要大括号了，更方便。</p><p>注解的定义和属性换成了kotlin的格式，这个也很容易看明白。Java里是@interface定义注解，kotlin里注解其实和class格式一样了，只不过用<code>annotation</code>关键字声明他是注解。</p><p>还有一个好处是，kotlin注解是一个类，所以使用时候可以按照构造函数的使用方法来使用，按顺序填入参数就行了，不用加参数名。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>接下来看反射，与Java不同的是，Java是一种纯面向对象的语言，所有东西都在类里面，所以我们要反射都是从一个类开始的。但是Kotlin还支持函数式编程，类之外还有函数和属性这些东西，所以kotlin中反射不止有类似Java的Class，还有其他的类型，kotlin文档对于反射的介绍是这样的：</p><blockquote><p>反射是这样的一组语言和库功能，它允许在运行时自省你的程序的结构。 Kotlin 让语言中的函数和属性做为一等公民、并对其自省（即在运行时获悉一个名称或者一个属性或函数的类型）与简单地使用函数式或响应式风格紧密相关。</p></blockquote><h3 id="使用Java的反射API"><a href="#使用Java的反射API" class="headerlink" title="使用Java的反射API"></a>使用Java的反射API</h3><p>要在kotlin里使用Java的反射，只要这样获取Java类引用就行：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> cls = MyClass::<span class="keyword">class</span>.java</span><br></pre></td></tr></table></figure><h3 id="使用kotlin官方的反射"><a href="#使用kotlin官方的反射" class="headerlink" title="使用kotlin官方的反射"></a>使用kotlin官方的反射</h3><p>使用反射首先添加反射的依赖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  implementation(<span class="string">&quot;org.jetbrains.kotlin:kotlin-reflect:1.4.20&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要获取类引用这样</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c = MyClass::<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure><p>关于函数和属性引用可以看文档:<a href="https://www.kotlincn.net/docs/reference/reflection.html">https://www.kotlincn.net/docs/reference/reflection.html</a></p><p>还是和上篇文章一样，我们来写一个反射函数处理刚才的注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span></span>()&#123;</span><br><span class="line">    <span class="meta">@MyAnno(<span class="meta-string">&quot;testtttttt&quot;</span>)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> name:String</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> mail:String=<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnno(<span class="meta-string">&quot;testtttttt2222&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setMail</span><span class="params">(mail: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mail=mail</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AnnoTest(name=&#x27;<span class="variable">$name</span>&#x27;, mail=&#x27;<span class="variable">$mail</span>&#x27;)&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reflect</span><span class="params">(myAnno: <span class="type">Any</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> cls = myAnno::<span class="class"><span class="keyword">class</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有字段</span></span><br><span class="line">    <span class="keyword">val</span> fields = cls.declaredMemberProperties</span><br><span class="line">    <span class="keyword">for</span> (field <span class="keyword">in</span> fields)&#123;</span><br><span class="line">        <span class="comment">//直接修改字段</span></span><br><span class="line">        <span class="keyword">val</span> anno = field.findAnnotation&lt;MyAnno&gt;()</span><br><span class="line">        <span class="keyword">if</span> (anno != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="meta">@Suppress(<span class="meta-string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="keyword">val</span> mutfield = field <span class="keyword">as</span> KMutableProperty1&lt;Any,Any&gt;</span><br><span class="line">            mutfield.isAccessible = <span class="literal">true</span></span><br><span class="line">            mutfield.<span class="keyword">set</span>(myAnno,anno.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用set方法</span></span><br><span class="line">    <span class="keyword">val</span> funcs = cls.functions</span><br><span class="line">    <span class="keyword">for</span> (func <span class="keyword">in</span> funcs)&#123;</span><br><span class="line">        <span class="keyword">val</span> anno = func.findAnnotation&lt;MyAnno&gt;()</span><br><span class="line">        <span class="keyword">if</span> (anno !=<span class="literal">null</span>)&#123;</span><br><span class="line">            func.call(myAnno,anno.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是和上次一样，我们的反射函数针对方法和属性进行注入，运行一下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> annoTest = AnnoTest()</span><br><span class="line">    reflect(annoTest)</span><br><span class="line">    println(annoTest)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line">AnnoTest(name=<span class="string">&#x27;testtttttt&#x27;</span>, mail=<span class="string">&#x27;testtttttt2222&#x27;</span>)</span><br></pre></td></tr></table></figure><p>成功注入！</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>既然两个反射都能用，两个都是编译成jvm字节码了，那么试试在Java里读取下注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> annoTest = AnnoTest()</span><br><span class="line">    <span class="keyword">val</span> cls = annoTest::<span class="keyword">class</span>.java</span><br><span class="line">    <span class="keyword">val</span> fields = cls.fields</span><br><span class="line">    <span class="keyword">for</span> (field <span class="keyword">in</span> fields)&#123;</span><br><span class="line">        <span class="keyword">val</span> anno =field.getAnnotation(MyAnno::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">if</span> (anno!=<span class="literal">null</span>)&#123;</span><br><span class="line">            println(anno.value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后没有输出，我们的注解没有被读到。怎么回事呢。</p><p>试试读出所有的注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> annoTest = AnnoTest()</span><br><span class="line">    <span class="keyword">val</span> cls = annoTest::<span class="keyword">class</span>.java</span><br><span class="line">    <span class="keyword">val</span> fields = cls.fields</span><br><span class="line">    <span class="keyword">for</span> (field <span class="keyword">in</span> fields)&#123;</span><br><span class="line">        <span class="keyword">val</span> annos =field.annotations</span><br><span class="line">        <span class="keyword">for</span> (anno <span class="keyword">in</span> annos)&#123;</span><br><span class="line">            println(anno)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是没有输出，看来我们的 字段上根本没有注解，试试读取方法的注解：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> annoTest = AnnoTest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cls = annoTest::<span class="keyword">class</span>.java</span><br><span class="line">    <span class="keyword">val</span> fields = cls.declaredMethods</span><br><span class="line">    <span class="keyword">for</span> (field <span class="keyword">in</span> fields)&#123;</span><br><span class="line">        <span class="keyword">val</span> annos =field.annotations</span><br><span class="line">        <span class="keyword">for</span> (anno <span class="keyword">in</span> annos)&#123;</span><br><span class="line">            println(anno)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="meta">@MyAnno(<span class="meta-string">&quot;testtttttt&quot;</span>)</span></span><br><span class="line"><span class="meta">@MyAnno(<span class="meta-string">&quot;testtttttt2222&quot;</span>)</span></span><br></pre></td></tr></table></figure><p>这次能看到了，看来属性的注入实际上是在set方法里了。这样的话，确实可以用Java的反射类来操作，就是用起来有点概念混乱，这两个语言里的元素不是一一对应，这么用容易出bug。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;/2021/07/28/202107282228/&quot;&gt;上一篇文章&lt;/a&gt;已经介绍了java的注解和反射，这篇文章来看看kotlin里面的注解和反射。&lt;/p&gt;</summary>
    
    
    
    
    <category term="kotlin" scheme="https://coolrc.me/tags/kotlin/"/>
    
    <category term="Java" scheme="https://coolrc.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解和用反射处理注解</title>
    <link href="https://coolrc.me/2021/07/28/202107282228/"/>
    <id>https://coolrc.me/2021/07/28/202107282228/</id>
    <published>2021-07-28T22:28:09.000Z</published>
    <updated>2021-07-28T22:28:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>研究下怎么在Java里定义注解，以及使用反射来读取和使用注解</p><span id="more"></span><h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。 Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留标注内容，在运行时可以获取到标注内容。– Wikipedia</p><p>意思就是注解只是一个标注，不会产生任何效果，要让注解起作用，还需要编写反射的代码来实现。</p><h3 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h3><p>还是先来看怎么定义一个注解，注解就是一个<code>@xxxx</code>开头的标注，一般这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD,FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码定义了一个叫做Myanno的注解。注解只有一个<code>String</code>类型的<code>value</code>属性，默认值为”hello”。<br>注解上面的注解叫做元注解,元注解是注解的注解。Java标准库里已经定义了几个元注解：Java 5 定义了 4 个注解，分别是 @Documented、@Target、@Retention 和 @Inherited。Java 8 又增加了 @Repeatable 和 @Native。关于这些注解的信息和使用方法可以自行查看文档。</p><p>这里用到的三个注解分别是：</p><ul><li>@Documented 代表这个注解会被加入Java doc里</li><li>@Target({METHOD,FIELD}) 注解可以使用的地方 这里METHOD,FIELD代表这个注解可以放在字段和方法上面</li><li>@Retention(RUNTIME) 注解的生命周期 这里RUNTIME意思是这个注解在运行时仍然生效</li></ul><p>注解的内部可以存放字段，默认的字段是value。可以用<code>@MyAnno(&quot;abcd&quot;)</code>直接使用，如果定义的是其他字段，就要用<code>@MyAnno(field = &quot;abcd&quot;)</code>这种方式。</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。 这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。 反射被视为动态语言的关键。 –百毒百科</p><p>意思就是反射可以在运行时获取类信息，构造对象，修改属性等东西，给Java这种静态语言增加了动态性。</p><p>Java的反射是通过反射包(<code>java.lang.reflect</code>)提供的。<br>Java是一个面向对象的语言，所以要反射先要获取类。所以一个反射的操作是这样的：</p><p>先来定义一个测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">&quot;name111&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;AnnoTest&gt; cls = AnnoTest.class;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(cls.getName());</span><br><span class="line">    Field field = cls.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    AnnoTest annoTest = <span class="keyword">new</span> AnnoTest();</span><br><span class="line">    System.out.println(field.get(annoTest));</span><br><span class="line">    field.set(annoTest,<span class="string">&quot;name222&quot;</span>);</span><br><span class="line">    System.out.println(field.get(annoTest));</span><br><span class="line">&#125; <span class="keyword">catch</span> .....</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line">com.company.AnnoTest</span><br><span class="line">name111</span><br><span class="line">name222</span><br></pre></td></tr></table></figure><ul><li>代码第1行获取AnnoTest的类</li><li>第3行打印AnnoTest类的名字 也就是<code>com.company.AnnoTest</code></li><li>第4行获取AnnoTest类的<code>name</code>字段</li><li>第5行我们新建一个实例</li><li>第6行对这个实例取出字段，返回的是我们设置的默认值name111</li><li>第7行我们给这个实例的字段重新设置一个值</li><li>第8行再次取出这个字段，可以看到name变成了name222</li></ul><p>不只是字段，反射还能读取方法和注解,对于刚才的注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnno(&quot;123456&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span> </span>&#123;&#125; <span class="comment">//对这个类使用注解</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(AnnoTest annoTest)</span> </span>&#123;</span><br><span class="line">    Class&lt;AnnoTest&gt; annoclass = AnnoTest.class;</span><br><span class="line">    MyAnno myAnno =  annoclass.getAnnotation(MyAnno.class);</span><br><span class="line">    System.out.println(myAnno.value());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reflect(<span class="keyword">new</span> AnnoTest())</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>执行上面的代码,可以看到，我们用反射成功获取到<code>AnnoTest</code>这个类的注解值。</p><h2 id="用反射来处理一个注解"><a href="#用反射来处理一个注解" class="headerlink" title="用反射来处理一个注解"></a>用反射来处理一个注解</h2><p>还是刚才那个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义注解</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target(&#123;METHOD,FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnno &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的期望是，将这个注解应用于类型为<code>String</code>的字段或者<code>String</code>参数的<code>set</code>方法，可以直接注入<code>value</code>的值或者将<code>value</code>作为参数传入set方法：</p><p>新建两个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MyAnno(&quot;testtttttt&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AnnoTest&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字段测试</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnoTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyAnno(&quot;testtttttt&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@MyAnno(&quot;testtttttt&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mail;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;AnnoTest2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mail=&#x27;&quot;</span> + mail + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编写一个反射函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了简便删去了try catch</span></span><br><span class="line"><span class="comment">//处理@MyAnno</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(Object annoTest)</span></span>&#123;</span><br><span class="line">    Field[] fields = annoTest.getClass().getDeclaredFields();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        MyAnno anno = field.getAnnotation(MyAnno.class);</span><br><span class="line">        <span class="keyword">if</span>(anno !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>); <span class="comment">//必须开启才能修改private属性</span></span><br><span class="line">            field.set(annoTest, anno.value());</span><br><span class="line">            field.setAccessible(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method[] methods = annoTest.getClass().getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        MyAnno anno = method.getAnnotation(MyAnno.class);</span><br><span class="line">        <span class="keyword">if</span>(anno !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            method.invoke(annoTest,anno.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数干了两件事：第一个for循环读取所有字段，遇到有注解的就注入value值；第二个for循环读取所有方法，碰到有注解的把value作为参数，执行这个(set)方法。</p><p>执行一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AnnoTest annotest = <span class="keyword">new</span> AnnoTest();</span><br><span class="line">    AnnoTest2 annoTest2 = <span class="keyword">new</span> AnnoTest2();</span><br><span class="line">    reflect(annoTest2);</span><br><span class="line">    reflect(annotest);</span><br><span class="line">    System.out.println(annotest);</span><br><span class="line">    System.out.println(annoTest2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// out</span></span><br><span class="line">AnnoTest&#123;name=<span class="string">&#x27;testtttttt&#x27;</span>&#125;</span><br><span class="line">AnnoTest2&#123;name=<span class="string">&#x27;testtttttt&#x27;</span>, mail=<span class="string">&#x27;testtttttt&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>第一个类的属性注解成功被注入，第二个类的set方法也成功被注入。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究下怎么在Java里定义注解，以及使用反射来读取和使用注解&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>在c++里使用rust的error和result，并实现backtrace</title>
    <link href="https://coolrc.me/2021/07/28/202107281713/"/>
    <id>https://coolrc.me/2021/07/28/202107281713/</id>
    <published>2021-07-28T16:49:32.000Z</published>
    <updated>2021-07-28T16:49:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>与c++和其他语言里面使用异常方式处理错误不同。rust和golang都采用特别的错误处理方式：golang利用函数有多个返回值的特性，直接把错误作为一个返回值。而rust则采用Result来包装函数返回值。这两种办法的好处是，每次调用代码时候都要原地处理错误，保证你不会遗漏任何未处理的错误。</p><span id="more"></span><p>那么怎么在c++里实现这种错误处理呢。<br>对于golang的错误处理，只要使用一个tuple就可以，没什么好说的。<br>这篇文章主要研究rust式的错误处理。</p><h3 id="rust源码"><a href="#rust源码" class="headerlink" title="rust源码"></a>rust源码</h3><p>先看rust的Result定义：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="comment">/// Contains the success value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="meta-string">&quot;Ok&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="literal">Ok</span>(<span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span> T),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Contains the error value</span></span><br><span class="line">    <span class="meta">#[lang = <span class="meta-string">&quot;Err&quot;</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span></span><br><span class="line">    <span class="literal">Err</span>(<span class="meta">#[stable(feature = <span class="meta-string">&quot;rust1&quot;</span>, since = <span class="meta-string">&quot;1.0.0&quot;</span>)]</span> E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去掉宏，其实就是一个枚举，立面有Ok和Err两个泛型成员。然后用match语句就可以方便的从枚举里取出结果。<br>除了match语句，result还提供了is_ok() ,ok(),err(),unwrap()等方法进行操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Error</span></span>: <span class="built_in">Debug</span> + Display &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Error是一个trait，主要是有Displaytrait，也就是打印错误。</p><h3 id="Result结构"><a href="#Result结构" class="headerlink" title="Result结构"></a>Result结构</h3><p>c++里面不存在泛型的enum，所以我们可以用一个模板类来代替。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> _isOk;</span><br><span class="line">    T ok;</span><br><span class="line">    E error;</span><br></pre></td></tr></table></figure><p>由于没有枚举，为了区分result是error还是ok，新增一个<code>_isOk</code>属性来标记。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOk</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _isOk; &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Result</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(T res)</span> : ok(res), _isOk(true) &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(E err)</span> : error(err), _isOk(false) &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">const</span> Result <span class="title">Ok</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">const</span> Result <span class="title">Error</span><span class="params">(<span class="keyword">const</span> E &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>增加一些基本的方法，两个构造函数分别初始化成功和失败两种类型，用Ok和Error两个友元新建Result类。isOk判断结果是否成功，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">E &amp;<span class="title">err</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> error; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">unwrap</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> T &amp;<span class="title">unwrap_or</span><span class="params">(T fallback)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再增加三个方法用来取出错误和执行成功的结构。</p><p>实现这些方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class E&gt;</span></span><br><span class="line"><span class="function">Result&lt;T, E&gt; <span class="title">Ok</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class E&gt;</span></span><br><span class="line"><span class="function">Result&lt;T, E&gt; <span class="title">Error</span><span class="params">(<span class="keyword">const</span> E &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T,class E&gt;</span></span><br><span class="line"><span class="function">Result&lt;T, E&gt; <span class="title">Ok</span><span class="params">(<span class="keyword">const</span> T &amp;res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result&lt;T, E&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T, class E&gt;</span></span><br><span class="line"><span class="function">Result&lt;T, E&gt; <span class="title">Error</span><span class="params">(<span class="keyword">const</span> E &amp;err)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result&lt;T, E&gt;(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="keyword">const</span> T &amp;Result&lt;T, E&gt;::<span class="built_in">unwrap</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isOk) &#123;</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;错误&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">E</span>&gt;</span></span><br><span class="line"><span class="keyword">const</span> T &amp;Result&lt;T, E&gt;::<span class="built_in">unwrap_or</span>(T fallback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_isOk)</span><br><span class="line">        <span class="keyword">return</span> ok;</span><br><span class="line">    <span class="keyword">return</span> fallback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Error类型"><a href="#Error类型" class="headerlink" title="Error类型"></a>Error类型</h3><p>上面的result是能接收任何类型的，为了能够统一错误输出，我们定义一个Err类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Err</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; msg;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string title=<span class="string">&quot;Error&quot;</span>;</span><br><span class="line">    <span class="function">string <span class="title">Error</span><span class="params">()</span></span>; <span class="comment">//输出错误信息</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Err <span class="title">As</span><span class="params">(<span class="keyword">const</span> std::exception &amp;e)</span></span>; <span class="comment">//把exception转为error</span></span><br><span class="line">    <span class="function">Err &amp;<span class="title">Append</span><span class="params">(<span class="keyword">const</span> string &amp;str)</span></span>; <span class="comment">//向错误信息后面增加描述</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一个最简单的Err类。可以处理exception，输出错误信息，并且随着调用增加描述信息。</p><p>但是这样的描述信息只有手动输入的文本，我们还想增加更多的属性，比如文件，行数等。我们可以自定义一个类来存储这些信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">errMsg</span> &#123;</span></span><br><span class="line">    string msg;</span><br><span class="line">    string file;</span><br><span class="line">    string func;</span><br><span class="line">    <span class="keyword">int</span> line;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">errMsg</span>() = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">errMsg</span>(string str,string file,string func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line) : <span class="built_in">msg</span>(std::<span class="built_in">move</span>(str)), <span class="built_in">file</span>(std::<span class="built_in">move</span>(file)), <span class="built_in">func</span>(std::<span class="built_in">move</span>(func)), <span class="built_in">line</span>(line) &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好了，这个类可以接收调用函数，文件，行数等信息。用它来替代<code>Err</code>类里的<code>msg</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Err</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;errMsg&gt; msg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string title=<span class="string">&quot;Error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Err</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Err</span>(<span class="keyword">const</span> string &amp;str,<span class="keyword">const</span> string &amp;file,<span class="keyword">const</span> string &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line);</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">Error</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Err <span class="title">As</span><span class="params">(<span class="keyword">const</span> std::exception &amp;e, <span class="keyword">const</span> string &amp;file, <span class="keyword">const</span> string  &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line)</span></span>; <span class="comment">//把exception转为error</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Err &amp;<span class="title">Append</span><span class="params">(<span class="keyword">const</span> string &amp;str,<span class="keyword">const</span> string &amp;file,<span class="keyword">const</span> string &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Err <span class="title">As</span><span class="params">(<span class="keyword">const</span> std::exception &amp;e, <span class="keyword">const</span> string &amp;file, <span class="keyword">const</span> string  &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line)</span></span>;</span><br></pre></td></tr></table></figure><p>这样每次在处理Err类的时候，都会把调用信息也存进去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;error.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::to_string;</span><br><span class="line"></span><br><span class="line"><span class="function">class Err <span class="title">As</span><span class="params">(<span class="keyword">const</span> std::exception &amp;e, <span class="keyword">const</span> string &amp;file, <span class="keyword">const</span> string  &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line)</span> </span>&#123;</span><br><span class="line">    string msg = e.<span class="built_in">what</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Err</span>(msg,file,func,line);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Err &amp;<span class="title">Err::Append</span><span class="params">(<span class="keyword">const</span> string &amp;str,<span class="keyword">const</span> string &amp;file,<span class="keyword">const</span> string &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> errmsg = <span class="built_in">errMsg</span>(str,file,func,line);</span><br><span class="line">    <span class="keyword">this</span>-&gt;msg.<span class="built_in">push_back</span>(errmsg);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印错误调用栈</span></span><br><span class="line"><span class="function">string <span class="title">Err::Error</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">auto</span> res = std::<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;title+<span class="string">&quot;:\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> end = <span class="keyword">this</span>-&gt;msg.<span class="built_in">rbegin</span>(); end != <span class="keyword">this</span>-&gt;msg.<span class="built_in">rend</span>(); ++end) &#123;</span><br><span class="line">        res.<span class="built_in">append</span>(<span class="string">&quot;    &quot;</span> + end-&gt;msg + <span class="string">&quot; at &quot;</span> + end-&gt;func + <span class="string">&quot; &quot;</span> + end-&gt;file + <span class="string">&quot;:&quot;</span> + <span class="built_in">to_string</span>(end-&gt;line) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Err::<span class="built_in">Err</span>(<span class="keyword">const</span> string &amp;str,<span class="keyword">const</span> string &amp;file,<span class="keyword">const</span> string &amp;func,<span class="keyword">const</span> <span class="keyword">int</span> &amp;line) &#123;</span><br><span class="line">    <span class="keyword">auto</span> errmsg = <span class="built_in">errMsg</span>(str,file,func,line);</span><br><span class="line">    <span class="keyword">this</span>-&gt;msg.<span class="built_in">push_back</span>(errmsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是问题；来了，难道要每次都手动输入文件名，行数吗？当然不可能这么麻烦。编译器立面已经由相关的宏了。<br>我们要做的就是想办法让这些宏自动填进去。<br>这里我们需要三个宏：<code>__FILE__</code> <code>__FUNCTION__</code> <code>__LINE__</code>。<br>自定义几个宏来自动填入这几个宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APPEND(err, msg) err.Append(msg,__FILE__,__FUNCTION__,__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR(msg) Err(msg,__FILE__,__FUNCTION__,__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AS_ERROR(exception) As(exception,__FILE__,__FUNCTION__,__LINE__)</span></span><br></pre></td></tr></table></figure><p>这样我们的error和result就能使用了</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用下面的代码测试一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;error.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BaseTest</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AsTest</span><span class="params">()</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> num = <span class="built_in">BaseTest</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (num.<span class="built_in">isOk</span>())</span><br><span class="line">        cout &lt;&lt; num.<span class="built_in">unwrap</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; num.<span class="built_in">err</span>().<span class="built_in">Error</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">AsTest</span>();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        res.<span class="built_in">unwrap</span>();</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">BaseTest</span><span class="params">(<span class="keyword">int</span> a)</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">test1</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">isOk</span>())</span><br><span class="line">        <span class="keyword">return</span> Ok&lt;<span class="keyword">int</span>, Err&gt;(res.<span class="built_in">unwrap</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Error&lt;<span class="keyword">int</span>, Err&gt;(<span class="built_in">APPEND</span>(res.<span class="built_in">err</span>(), <span class="string">&quot;cuowu2&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test1</span><span class="params">(<span class="keyword">int</span> a)</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">test</span>(a);</span><br><span class="line">    <span class="keyword">if</span> (res.<span class="built_in">isOk</span>())</span><br><span class="line">        <span class="keyword">return</span> Ok&lt;<span class="keyword">int</span>, Err&gt;(res.<span class="built_in">unwrap</span>());</span><br><span class="line">    <span class="keyword">return</span> Error&lt;<span class="keyword">int</span>, Err&gt;(<span class="built_in">APPEND</span>(res.<span class="built_in">err</span>(), <span class="string">&quot;cuowu1&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a)</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Ok&lt;<span class="keyword">int</span>, Err&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Error&lt;<span class="keyword">int</span>, Err&gt;(<span class="built_in">ERROR</span>(<span class="string">&quot;cuowu&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">AsTest</span><span class="params">()</span> -&gt; Result&lt;<span class="keyword">int</span>, Err&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;asdasdad&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;msg) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error&lt;<span class="keyword">int</span>, Err&gt;(<span class="built_in">AS_ERROR</span>(msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">L:\source_code\cpp\cpptest\cmake-build-debug\cpperror.exe</span><br><span class="line">error:</span><br><span class="line">    cuowu2 at BaseTest L:\source_code\cpp\cpptest\main.cpp:68</span><br><span class="line">    cuowu1 at test1 L:\source_code\cpp\cpptest\main.cpp:75</span><br><span class="line">    cuowu at test L:\source_code\cpp\cpptest\main.cpp:83</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    asdasdad at AsTest L:\source_code\cpp\cpptest\main.cpp:91</span><br><span class="line"></span><br><span class="line">Failed to unwrap</span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure><p>第一个error说明，我们的错误确实能够逐级输出调用栈了。<br>第二个error说明，我们的错误也能把exception转化为Err。<br>更厉害的是，我们的错误输出可以被ide识别，只要点击就能跳转到对应的代码了，是不是非常方便。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的只是我学习cpp过程中随便写的，还存在不少缺陷。写完这篇文章时候去Google了一下，github有人写了差不多的一个项目：<a href="https://github.com/oktal/result">https://github.com/oktal/result</a>，有兴趣的可以去看看。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;与c++和其他语言里面使用异常方式处理错误不同。rust和golang都采用特别的错误处理方式：golang利用函数有多个返回值的特性，直接把错误作为一个返回值。而rust则采用Result来包装函数返回值。这两种办法的好处是，每次调用代码时候都要原地处理错误，保证你不会遗漏任何未处理的错误。&lt;/p&gt;</summary>
    
    
    
    <category term="c++" scheme="https://coolrc.me/categories/c/"/>
    
    
    <category term="c++" scheme="https://coolrc.me/tags/c/"/>
    
    <category term="rust" scheme="https://coolrc.me/tags/rust/"/>
    
    <category term="error" scheme="https://coolrc.me/tags/error/"/>
    
    <category term="exception" scheme="https://coolrc.me/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>远程启动不支持网络唤醒的pc</title>
    <link href="https://coolrc.me/2020/09/16/2020091620/"/>
    <id>https://coolrc.me/2020/09/16/2020091620/</id>
    <published>2020-09-16T20:59:58.000Z</published>
    <updated>2020-11-14T15:59:58.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>update: 修改了代码，现在可以实时检测电脑是否在线</p><hr><blockquote><p><code>Wake-on-LAN</code>简称<code>WOL</code>或<code>WoL</code>，中文多译为“网络唤醒”、“远程唤醒”技术。WOL是一种技术，同时也是该技术的规范标准，它的功效在于让休眠状态或关机状态的电脑，透过局域网的另一台电脑对其发令，使其唤醒、恢复成运作状态，或从关机状态转成引导状态。</p></blockquote><p>对于支持网络唤醒的主机，我们可以使用路由器的网络唤醒功能来开机。但是网络唤醒需要的是网卡和主板的支持，还需要你有公网ip或者路由器支持远程唤醒，任何一项不支持都不能正常启动。而且即使支持了网络唤醒，万一遇到了意外断电，有的主板也不能正常开机。<span id="more"></span>那么有什么办法能保证网络唤醒一定成功呢？</p><p>最简单的方法是智能插座，在BIOS里设置好主板通电就开机，然后远程控制智能插座就可以了。这种方法最简单，但是笔记本是有电池的，所以BIOS里一般没有通电开机的选项，这个办法就行不通了。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>那么怎么办呢，首先我们来了解一下电脑的启动流程：<br>开机按键一端和电源14脚或16脚相接，另一端接地，当我们按下电源按钮时，电源的14或16脚接地，然后就会触发电源开始工作，向设备供电。（这种说法只是为了方便理解，实际流程很复杂）</p><p>既然知道了这个原理，那我们只要让电源引脚接地，模拟开机键按下的过程，不就能开机了吗。</p><p>为了实现这个功能，需要以下材料：</p><ul><li>一个esp8266，用于联网</li><li>一个esp8266 relay，用于短接电源引脚，</li><li>一个usb转ttl，同于给esp8266刷写程序</li><li>电烙铁，用于引出开机线路</li><li>一个万用表，用于测试</li><li>esp8266开发软件，我用的是arduino IDE</li></ul><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>首先需要的，当然是拆开电脑，找到对应的启动引脚了，台式机的话很简单，看电源按钮排线就行，笔记本的话，可以直接看电源按钮的线路，也可以找根线，一端接地，一端在电源按钮排线上一个一个短接试过去。</p><p>找到引脚后，就要想办法用电烙铁引过来地线和电源线，这里推荐用耳机线，很软很细不容易断，不会让设备外壳合不上。</p><p>然后把这两根线接到继电器的公共口和常闭口就行。</p><h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>接着就要写程序远程控制继电器开合。推荐使用点灯科技的<code>blinker</code>SDK,配合手机app可以很方便的控制。blinker使用方法请自行搜索，</p><p>新建一个blinker设备，获得Secret Key，然后开始编程：<br>需要用到的库：<a href="https://github.com/dancol90/ESP8266Ping">ESP8266Ping</a>,注意不是arduino仓库里的那个ESP8266-ping，这个要自己下载放到libraries文件夹里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLINKER_WIFI</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIO 0 <span class="comment">//继电器引脚</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLINKER_MIOT_OUTLET</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Blinker.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266Ping.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> pwstate = <span class="literal">false</span>;<span class="comment">//电源状态</span></span><br><span class="line"><span class="function">IPAddress <span class="title">IP</span> <span class="params">(<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">104</span>)</span></span>; <span class="comment">//电脑ip，检测是否开机</span></span><br><span class="line"><span class="keyword">char</span> auth[] = <span class="string">&quot;你的key&quot;</span>;<span class="comment">//app中获取到的Secret Key(密钥)</span></span><br><span class="line"><span class="keyword">char</span> ssid[] = <span class="string">&quot;qwweqrq&quot;</span>; <span class="comment">//你的wifi 名称</span></span><br><span class="line"><span class="keyword">char</span> pswd[] = <span class="string">&quot;password&quot;</span>; <span class="comment">//你的wifi 密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建组件对象</span></span><br><span class="line"><span class="function">BlinkerButton <span class="title">Button1</span><span class="params">(<span class="string">&quot;btn-abc&quot;</span>)</span></span>;<span class="comment">//注意：内容替换为app中添加按键的数据键名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按下BlinkerAPP按键即会执行该函数</span></span><br><span class="line"><span class="comment">// 按下按键即会执行该函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">statusreport</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pwstate)</span><br><span class="line">  &#123;</span><br><span class="line">    Button1.print(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">    BlinkerMIOT.powerState(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    Button1.print(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">    BlinkerMIOT.powerState(<span class="string">&quot;off&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  BlinkerMIOT.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isonline</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//  for (int i=0;i&lt;3;i++)</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (Ping.ping(IP)) &#123;</span><br><span class="line">      <span class="comment">//BLINKER_LOG(&quot;ping成功！&quot;,IP);</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    delay(3000);</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">  <span class="comment">//BLINKER_LOG(&quot;ping失败！&quot;,IP);</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heartbeat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isonline()) pwstate = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span> pwstate = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//BLINKER_LOG(&quot;电源状态&quot;,pwstate);</span></span><br><span class="line">  statusreport();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waiteforpwstate</span><span class="params">(<span class="keyword">bool</span> pw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; pw != (pwstate = isonline()) &amp;&amp; i &lt;= <span class="number">10</span>; i++) <span class="comment">//不满足条件就持续ping，直到30次</span></span><br><span class="line">  &#123;</span><br><span class="line">    delay(<span class="number">3000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">(<span class="keyword">const</span> String &amp; state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((state == BLINKER_CMD_ON &amp;&amp;pwstate)||(state == BLINKER_CMD_OFF &amp;&amp; !pwstate)) <span class="keyword">return</span>; <span class="comment">//状态不变的话就不要按下按钮</span></span><br><span class="line">  <span class="comment">//长按1.5s开机</span></span><br><span class="line">  digitalWrite(GPIO, LOW);</span><br><span class="line">  delay(<span class="number">1500</span>);</span><br><span class="line">  digitalWrite(GPIO, HIGH);</span><br><span class="line">  <span class="keyword">if</span> (state == BLINKER_CMD_ON) waiteforpwstate(<span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">else</span> waiteforpwstate(<span class="literal">false</span>);</span><br><span class="line">  statusreport();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">miotPowerState</span><span class="params">(<span class="keyword">const</span> String &amp; state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  click(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">button1_callback</span><span class="params">(<span class="keyword">const</span> String &amp; state)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  click(state);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">miotQuery</span><span class="params">(<span class="keyword">int32_t</span> queryCode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  statusreport();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 初始化串口，并开启调试信息，调试用可以删除</span></span><br><span class="line">  Serial.begin(<span class="number">115200</span>);</span><br><span class="line">  BLINKER_DEBUG.stream(Serial);</span><br><span class="line">  <span class="comment">// 初始化IO</span></span><br><span class="line">  pinMode(GPIO, OUTPUT);</span><br><span class="line">  digitalWrite(GPIO, HIGH);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//指示灯</span></span><br><span class="line">  <span class="comment">//digitalWrite(LED_BUILTIN, LOW);</span></span><br><span class="line">  <span class="comment">//delay(1500);</span></span><br><span class="line">  <span class="comment">//digitalWrite(LED_BUILTIN, HIGH);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化blinker</span></span><br><span class="line">  Blinker.begin(auth, ssid, pswd);</span><br><span class="line">  Button1.attach(button1_callback);</span><br><span class="line">  Blinker.attachHeartbeat(heartbeat);</span><br><span class="line">  BlinkerMIOT.attachQuery(miotQuery);</span><br><span class="line">  BlinkerMIOT.attachPowerState(miotPowerState);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Blinker.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="tip"><del>Blinker还可以支持小爱同学远程控制，不过我懒得写了，以后再补上</del></p>已经添加小爱同学代码，不过由于开关机需要一定时间，小爱同学不能及时感知到操作是否成功。<p>程序的刷写方法可以参考这里：<a href="https://www.diyhobi.com/flash-program-esp-01-using-usb-serial-adapter/">https://www.diyhobi.com/flash-program-esp-01-using-usb-serial-adapter/</a></p><p>接法是这样的：<br><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/09/16/5f6214d9160a154a67895e9a.jpg" alt="esp8266 ttl针脚接线"></p><p>写好之后，在blinker app立面编辑界面，新增一个按钮，数据键名为<code>btn-abc</code>,<del>类型为普通按键</del>(现在可以选择开关按键，样式选择第二个滑块按钮可以看到机器开关状态)。然后就可以用了<br><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/09/16/5f621601160a154a6789ce67.jpg" alt="blinker控制"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;update: 修改了代码，现在可以实时检测电脑是否在线&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Wake-on-LAN&lt;/code&gt;简称&lt;code&gt;WOL&lt;/code&gt;或&lt;code&gt;WoL&lt;/code&gt;，中文多译为“网络唤醒”、“远程唤醒”技术。WOL是一种技术，同时也是该技术的规范标准，它的功效在于让休眠状态或关机状态的电脑，透过局域网的另一台电脑对其发令，使其唤醒、恢复成运作状态，或从关机状态转成引导状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于支持网络唤醒的主机，我们可以使用路由器的网络唤醒功能来开机。但是网络唤醒需要的是网卡和主板的支持，还需要你有公网ip或者路由器支持远程唤醒，任何一项不支持都不能正常启动。而且即使支持了网络唤醒，万一遇到了意外断电，有的主板也不能正常开机。</summary>
    
    
    
    
    <category term="开机棒" scheme="https://coolrc.me/tags/%E5%BC%80%E6%9C%BA%E6%A3%92/"/>
    
    <category term="硬件" scheme="https://coolrc.me/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>添加windows-terminal到右键菜单</title>
    <link href="https://coolrc.me/2020/09/13/2020091321/"/>
    <id>https://coolrc.me/2020/09/13/2020091321/</id>
    <published>2020-09-13T21:51:56.000Z</published>
    <updated>2020-09-13T21:51:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>新版的<code>Windows terminal</code>很好用，不过不能像powershell那样右键直接在文件夹打开。我们可以通过修改注册表的方式手动添加右键菜单。<span id="more"></span></p><h2 id="了解参数"><a href="#了解参数" class="headerlink" title="了解参数"></a>了解参数</h2><p>首先，右键菜单的地址在：<code>计算机\HKEY_CLASSES_ROOT\Directory\Background\shell\</code>这个文件夹下面，我们在这里添加键值就能在右键菜单看到了。</p><p>再来看<code>Windows terminal</code>的参数：</p><p><code>-d</code>参数可以指定指定打开的目录，所以这里我们使用<code>C:\Users\你的用户名\AppData\Local\Microsoft\WindowsApps\wt.exe -d .</code>这个命令就能在当前文件夹打开<code>Windows terminal</code>。</p><p><code>-p</code>参数可以指定要使用哪个shell，shell的名字就是就是<code>Windows terminal</code>里面配置的<code>name</code>参数，所以通过<code>C:\Users\你的用户名\AppData\Local\Microsoft\WindowsApps\wt.exe -p &quot;Windows PowerShell&quot; -d .</code>这个命令就能在当前文件夹使用<code>Windows PowerShell</code>来打开<code>Windows terminal</code>。</p><h2 id="配置注册表"><a href="#配置注册表" class="headerlink" title="配置注册表"></a>配置注册表</h2><p>有了上述的前置知识，我们就知道应该怎么配置右键菜单了。比如用默认shell打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@=&quot;Windows Terminal Here&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@=&quot;C:\\Users\\你的用户名\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe -d .&quot;</span><br></pre></td></tr></table></figure><p>用<code>wsl2</code>打开：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@=&quot;WSL Here&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@=&quot;C:\\Users\\你的用户名\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe -p ubuntu -d .&quot;</span><br></pre></td></tr></table></figure><p>要让右键菜单默认隐藏，按shift才能出现的话，可以添加一行<code>&quot;Extended&quot;=&quot;&quot;</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@=&quot;Windows Terminal Here&quot;</span><br><span class="line">&quot;Extended&quot;=&quot;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@=&quot;C:\\Users\\你的用户名\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe -d .&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>把上述代码保存为<code>.reg</code>文件运行即可。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;新版的&lt;code&gt;Windows terminal&lt;/code&gt;很好用，不过不能像powershell那样右键直接在文件夹打开。我们可以通过修改注册表的方式手动添加右键菜单。</summary>
    
    
    
    
    <category term="windows" scheme="https://coolrc.me/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>arm平台安装docker-compose</title>
    <link href="https://coolrc.me/2020/03/21/202003212046/"/>
    <id>https://coolrc.me/2020/03/21/202003212046/</id>
    <published>2020-03-21T20:46:26.000Z</published>
    <updated>2020-03-21T20:46:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/03/21/5e76134f9d7d586a540ff542.jpg" alt="docker logo"><br>github上的仓库里没有编译arm版本的docker-compose，需要自己编译，这里记录编译的办法。</p><span id="more"></span><p>我使用的系统是<code>Debian buster</code>,首先安装docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://get.docker.com -o get-docker.sh</span><br></pre></td></tr></table></figure><p>接下来安装docker-compose，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python python-pip python-dev python-setuptools libffi-dev</span><br><span class="line">pip install pip -U</span><br><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">sudo pip install docker-compose</span><br></pre></td></tr></table></figure><p>然后等待一万年。。。。。让pip自动帮你编译安装就可以用了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/03/21/5e76134f9d7d586a540ff542.jpg&quot; alt=&quot;docker logo&quot;&gt;&lt;br&gt;github上的仓库里没有编译arm版本的docker-compose，需要自己编译，这里记录编译的办法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="docker" scheme="https://coolrc.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu配置postfix使用SMTP发送邮件</title>
    <link href="https://coolrc.me/2020/03/21/202003211618/"/>
    <id>https://coolrc.me/2020/03/21/202003211618/</id>
    <published>2020-03-21T16:18:13.000Z</published>
    <updated>2020-03-21T16:18:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/03/21/5e75d31c9d7d586a54da48dc.jpg" alt="mail"><br>昨天配置了个定时任务需要发送邮件确认是否执行成功，就折腾了一下Linux的邮件，走了很多弯路才搞成功，这里记录一下配置过程吧<span id="more"></span></p><p>主要参考的文章是:<a href="https://itlaws.cn/post/postfix-use-external-smtp/">Postfix使用外部SMTP服务器发送邮件</a></p><p>接下来我补充一些注意事项</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mailutils</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/postfix/sasl_passwd</span><br><span class="line"><span class="comment">#写入SMTP账号密码</span></span><br><span class="line">[smtp.qq.com]:465 myEmail:password</span><br></pre></td></tr></table></figure><p>qq邮箱的密码需要在<code>设置-帐号</code>里生成授权码<br>然后加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo postmap /etc/postfix/sasl_passwd</span><br></pre></td></tr></table></figure><h3 id="映射发件人"><a href="#映射发件人" class="headerlink" title="映射发件人"></a>映射发件人</h3><p>默认是用你的用户名@主机名的方式发送邮件的，这样的邮件会被smtp服务器拒绝，所以要把发件人映射为你的qq邮箱地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/postfix/generic</span><br><span class="line"><span class="comment">#写入映射关系</span></span><br><span class="line">root@myhostname     12345678@qq.com</span><br></pre></td></tr></table></figure><p>myhostname是<code>/etc/postfix/main.cf</code>里面的<code>myhostname</code>。</p><p>加密</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo postmap /etc/postfix/generic</span><br></pre></td></tr></table></figure><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim /etc/postfix/main.cf</span><br><span class="line"></span><br><span class="line">#修改relayhost</span><br><span class="line">relayhost = [smtp.exmail.qq.com]:465</span><br><span class="line"></span><br><span class="line">#加入以下内容</span><br><span class="line"># enable SASL authentication</span><br><span class="line">smtp_sasl_auth_enable = yes</span><br><span class="line"></span><br><span class="line"># disallow methods that allow anonymous authentication.</span><br><span class="line">smtp_sasl_security_options = noanonymous</span><br><span class="line"></span><br><span class="line"># where to find sasl_passwd</span><br><span class="line">smtp_sasl_password_maps = hash:/etc/postfix/sasl_passwd</span><br><span class="line"></span><br><span class="line"># where to find generic</span><br><span class="line">smtp_generic_maps = hash:/etc/postfix/generic</span><br><span class="line"></span><br><span class="line"># Enable STARTTLS encryption</span><br><span class="line">smtp_use_tls = yes</span><br><span class="line"></span><br><span class="line"># where to find CA certificates</span><br><span class="line">smtp_tls_CAfile = /etc/ssl/certs/ca-certificates.crt</span><br><span class="line"></span><br><span class="line"># Enable tls encryption</span><br><span class="line">smtp_tls_wrappermode = yes</span><br><span class="line">smtp_tls_security_level = encrypt</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>接下来重启postfix就可以发信了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service postfix restar</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;test&quot;</span> | mail -s <span class="string">&quot;hello&quot;</span> 123@qq.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/03/21/5e75d31c9d7d586a54da48dc.jpg&quot; alt=&quot;mail&quot;&gt;&lt;br&gt;昨天配置了个定时任务需要发送邮件确认是否执行成功，就折腾了一下Linux的邮件，走了很多弯路才搞成功，这里记录一下配置过程吧</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>新建了个doh+dot服务器</title>
    <link href="https://coolrc.me/2020/02/05/202002051/"/>
    <id>https://coolrc.me/2020/02/05/202002051/</id>
    <published>2020-02-05T17:13:49.000Z</published>
    <updated>2020-02-05T17:13:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天geekdns的加密dns用不了了，于是今天就自己整了个dns服务器。<br>具体的地址就不发了，免得查水表，下面说一下搭建的步骤吧。</p><span id="more"></span><p>项目地址：<a href="https://github.com/coolrc136/Pcap_DNSProxy_docker/tree/overture">https://github.com/coolrc136/Pcap_DNSProxy_docker/tree/overture</a><br>记得切换到overture分支</p><p>服务器要用的软件已经用<code>docker-compose</code>打包好了，pull下来直接跑就行。<br>我来说一下具体的结构吧，懒得画图了，直接用文字，很简单：</p><p>用户通过tls或者https向服务器请求dns</p><h3 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h3><p>如果是tls的话，仅仅是对tcp格式的dns请求进行了ssl加密而已，直接用nginx的stream模块进行tcp反代。然后dns请求传到overture，overture进行分流查询</p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>如果是https的话，dns请求是用json格式传输的，我们需要dns-over-https这个软件来进行协议转换。<br>首先nginx反代http请求到dns-over-https，然后dns-over-https把请求转换为普通的udp查询传给overture，再由overture发出请求。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安卓手机在加密dns选项填上服务器域名或ip就行。</p><p>windows用Auroradns，主dns填入：<a href="https://域名/dns-query">https://域名/dns-query</a>就可以</p><p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2020/02/05/5e3a8b842fb38b8c3cc68386.jpg" alt="Auroradns"></p><p class="tip">更新：实际使用了两天，windows端还是`simple dnscrypt-proxy`好用,但是配置麻烦，这里不写了，具体使用方法看项目README：<a herf="https://github.com/coolrc136/Pcap_DNSProxy_docker/blob/overture/README.md">https://github.com/coolrc136/Pcap_DNSProxy_docker/blob/overture/README.md</a>。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;昨天geekdns的加密dns用不了了，于是今天就自己整了个dns服务器。&lt;br&gt;具体的地址就不发了，免得查水表，下面说一下搭建的步骤吧。&lt;/p&gt;</summary>
    
    
    
    
    <category term="dns" scheme="https://coolrc.me/tags/dns/"/>
    
    <category term="doh" scheme="https://coolrc.me/tags/doh/"/>
    
    <category term="dot" scheme="https://coolrc.me/tags/dot/"/>
    
    <category term="dns-over-https" scheme="https://coolrc.me/tags/dns-over-https/"/>
    
    <category term="dns-over-tls" scheme="https://coolrc.me/tags/dns-over-tls/"/>
    
  </entry>
  
  <entry>
    <title>论如何保护安卓的DNS</title>
    <link href="https://coolrc.me/2019/07/16/201907161118/"/>
    <id>https://coolrc.me/2019/07/16/201907161118/</id>
    <published>2019-07-16T11:18:48.000Z</published>
    <updated>2019-07-16T11:18:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/07/16/5d2d4c70451253d178527789.jpg" alt="dns leak test"><br>传统的UDP DNS泄漏隐私，容易被篡改。尤其是隐私问题，你的运营商可以轻易知道你访问过哪些网站，想想都可怕。因此加密DNS显得尤为重要。<span id="more"></span><br>当然，DNS只是你访问互联网的第一个步骤而已，加密DNS并不能保证万无一失。HTTP自不必说，对于HTTPS，当你和服务器握手时，SNI也会暴露你访问的域名。但是，这并不代表加密dns没有用，至少在我朝网络环境下，可以保证DNS不被篡改，减少攻击面。</p><p class="tip">在TLS1.3中已经可以加密SNI了，可以通过在firefox中开启ESNI实现，但是需要服务端和客户端都支持，预计还要几年才能普及。</p><p>在PC上，加密dns很简单，只需要下载一个<a href="https://simplednscrypt.org/">SimpleDnsCrypt</a>,他就能自动帮你配好<code>dnscrypt-proxy</code>了。Linux的话，除了<code>dnscrypt-proxy</code>，还有<code>dns-overtls</code>和<code>dns-over-https</code>的各种软件可供选择。但是在安卓手机上，想要实现加密DNS就比较难了。</p><h2 id="dns-over-tls"><a href="#dns-over-tls" class="headerlink" title="dns-over-tls"></a>dns-over-tls</h2><p>从安卓9开始，就自带了加密dns功能，只要你在设置里填上合适的服务器地址就行，但是呢，这个自带的加密dns在使用代理时不会生效，如果你使用了SS，那么你还是会用SS里的DNS服务器明文查询，而且只能填一个域名，容易出故障。</p><h2 id="dnscrypt-proxy"><a href="#dnscrypt-proxy" class="headerlink" title="dnscrypt-proxy"></a>dnscrypt-proxy</h2><p>为了让全局DNS都能加密，这里就要使用一个<code>magisk</code>模块了，那就是<code>dnscrypt-proxy</code>。这个是<code>dnscrypt-proxy</code>的ARM版本，用<code>magisk</code>刷入，然后修改位于<code>/sdcard/dnscrypt-proxy</code>目录下的文件就能启用了。</p><p class="tip">为了方便配置，你可以在PC端用`SimpleDnsCrypt`配置好，然后把配置文件`dnscrypt-proxy.toml`复制过去。PC端默认监听53端口，建议修改为5353端口</p>这是我的配置文件：<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server_names</span> = [<span class="string">&quot;rubyfish-ea&quot;</span>, <span class="string">&quot;geekdns-doh-west&quot;</span>, <span class="string">&quot;geekdns-doh-north&quot;</span>, <span class="string">&quot;geekdns-doh-east&quot;</span>]</span><br><span class="line"><span class="attr">listen_addresses</span> = [<span class="string">&quot;127.0.0.1:53&quot;</span>, <span class="string">&quot;[::1]:53&quot;</span>]</span><br><span class="line"><span class="attr">max_clients</span> = <span class="number">250</span></span><br><span class="line"><span class="attr">ipv4_servers</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">ipv6_servers</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">disabled_server_names</span> = []</span><br><span class="line"><span class="attr">refused_code_in_responses</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">dnscrypt_servers</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">doh_servers</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">require_dnssec</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">require_nolog</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">require_nofilter</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">daemonize</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">force_tcp</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">dnscrypt_ephemeral_keys</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">tls_disable_session_tickets</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">offline_mode</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">2500</span></span><br><span class="line"><span class="attr">keepalive</span> = <span class="number">30</span></span><br><span class="line"><span class="attr">lb_estimator</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">netprobe_timeout</span> = <span class="number">60</span></span><br><span class="line"><span class="attr">netprobe_address</span> = <span class="string">&quot;9.9.9.9:53&quot;</span></span><br><span class="line"><span class="attr">log_level</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">use_syslog</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">cert_refresh_delay</span> = <span class="number">240</span></span><br><span class="line"><span class="attr">fallback_resolver</span> = <span class="string">&quot;223.5.5.5:53&quot;</span></span><br><span class="line"><span class="attr">ignore_system_dns</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">log_files_max_size</span> = <span class="number">10</span></span><br><span class="line"><span class="attr">log_files_max_age</span> = <span class="number">7</span></span><br><span class="line"><span class="attr">log_files_max_backups</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">block_ipv6</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">cache</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">cache_size</span> = <span class="number">256</span></span><br><span class="line"><span class="attr">cache_min_ttl</span> = <span class="number">600</span></span><br><span class="line"><span class="attr">cache_max_ttl</span> = <span class="number">86400</span></span><br><span class="line"><span class="attr">cache_neg_ttl</span> = <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="section">[query_log]</span></span><br><span class="line"><span class="attr">format</span> = <span class="string">&quot;ltsv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[nx_log]</span></span><br><span class="line"><span class="attr">format</span> = <span class="string">&quot;ltsv&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[blacklist]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[ip_blacklist]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[sources]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[sources.public-resolvers]</span></span><br><span class="line"><span class="attr">urls</span> = [<span class="string">&quot;https://raw.githubusercontent.com/DNSCrypt/dnscrypt-resolvers/master/v2/public-resolvers.md&quot;</span>, <span class="string">&quot;https://download.dnscrypt.info/resolvers-list/v2/public-resolvers.md&quot;</span>]</span><br><span class="line"><span class="attr">minisign_key</span> = <span class="string">&quot;RWQf6LRCGA9i53mlYecO4IzT51TGPpvWucNSCh1CBM0QTaLn73Y7GFO3&quot;</span></span><br><span class="line"><span class="attr">cache_file</span> = <span class="string">&quot;public-resolvers.md&quot;</span></span><br><span class="line"><span class="attr">refresh_delay</span> = <span class="number">72</span></span><br><span class="line"><span class="attr">prefix</span> = <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>然后，你有两个选择，一是安装一个修改dns的app，将dns指向dnscrypt-proxy监听的地址，比如我这里是<code>127.0.0.1:5353</code>，填进去，然后app一般会启动一个vpn，用这个vpn上网就行。<br>如果不想用vpn，那么可以安装<a href="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/files/CloudflareDNS4Magisk-v2.6.zip">这个magisk模块</a>,这个模块会使用<code>iptables</code>把所有53端口的出口流量转到<code>127.0.0.1:5353</code>，也就是全局启用了<code>dnscrypt-proxy</code>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>配置完dns后，我们来测试一下有没有成功,访问<a href="https://www.dnsleaktest.com/">https://www.dnsleaktest.com/</a>或者<a href="http://nstool.netease.com/">http://nstool.netease.com/</a>。如果看到的DNS和你在<code>dnscrypt-proxy</code>中配置的一样，恭喜你，你的DNS已经被加密了。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.hetianlab.com/html/news/news-2018042001.html">浅析加密DNS</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/07/16/5d2d4c70451253d178527789.jpg&quot; alt=&quot;dns leak test&quot;&gt;&lt;br&gt;传统的UDP DNS泄漏隐私，容易被篡改。尤其是隐私问题，你的运营商可以轻易知道你访问过哪些网站，想想都可怕。因此加密DNS显得尤为重要。</summary>
    
    
    
    
    <category term="手机" scheme="https://coolrc.me/tags/%E6%89%8B%E6%9C%BA/"/>
    
    <category term="DNS" scheme="https://coolrc.me/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>给波兰版MIUI用上国内主题</title>
    <link href="https://coolrc.me/2019/07/16/201907160958/"/>
    <id>https://coolrc.me/2019/07/16/201907160958/</id>
    <published>2019-07-16T09:58:29.000Z</published>
    <updated>2019-07-16T09:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>迫于各种原生的ROM BUG太多，昨天又刷回了MIUI。但是我的MIUI是波兰版的，里面自带的主题商店只有国外的主题，比较简陋。那想用回国内主题怎么办呢？</p><span id="more"></span><h3 id="optinon-1"><a href="#optinon-1" class="headerlink" title="optinon 1"></a>optinon 1</h3><p>首先想到的肯定是把国内版的主题商店移植回来，这样就能一直用了，但是调查后才发现，用国内版主题商店需要修改<code>build.prop</code>,这样的话，就会让一些广告重新出现，所以这个方案对我来说并不行。</p><h3 id="option-2"><a href="#option-2" class="headerlink" title="option 2"></a>option 2</h3><p>其实我只是需要安装一个主题而已，为何不直接导入MTZ呢？这时候就要用到一个油猴插件，那就是<a href="https://greasyfork.org/en/scripts/374648-miui-%E4%B8%BB%E9%A2%98%E4%B8%8B%E8%BD%BD%E5%99%A8">MIUI主题下载器</a>。安装这个插件，前往<a href="http://zhuti.xiaomi.com/">http://zhuti.xiaomi.com</a>就能看到下载按钮了。<br><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/07/16/5d2d31fa451253d178512fbf.jpg" alt="小米商店"><br>然后下载，用主题商店导入就是了,波兰版的主题商店没有收费功能，所以即使是收费的主题也能直接导入后应用。唯一有点麻烦的就是，后面要升级的话就得再手动下载一次。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;迫于各种原生的ROM BUG太多，昨天又刷回了MIUI。但是我的MIUI是波兰版的，里面自带的主题商店只有国外的主题，比较简陋。那想用回国内主题怎么办呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="手机" scheme="https://coolrc.me/tags/%E6%89%8B%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>ARCGIS网络分析</title>
    <link href="https://coolrc.me/2019/04/03/201904032251/"/>
    <id>https://coolrc.me/2019/04/03/201904032251/</id>
    <published>2019-04-03T22:51:37.000Z</published>
    <updated>2019-04-03T22:51:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>ArcGIS Network Analyst 扩展模块 可以解决一般的网络问题，例如查找穿过城市的最佳路线，查找最近的急救车辆或设施点，识别某一位置周围的服务区，使用一支车队为一组订单提供服务，或选择要设立或关闭的最佳设施点。<span id="more"></span></p><h3 id="STEP-1-地图的获取"><a href="#STEP-1-地图的获取" class="headerlink" title="STEP 1 地图的获取"></a>STEP 1 地图的获取</h3><p>要进行网络分析，我们需要的是矢量的道路网地图。一般自己想办法绘制或者购买数据才能得到精确的底图。路网的要求不是很细致的话，那还有一个办法是从<a href="%5Bhttps://www.openstreetmap.org%5D(https://www.openstreetmap.org/)">openstreetmap</a>上面下载公开的地图。OpenStreetMap是一个开源地图项目，任何人都可以在上面编辑地图。但是国内用户比较少，上面的路网比较残缺。不过缺少的基本都是小区内的道路，城市道路还是比较完整的。</p><p>从OpenStreetMap上面下载下来的地图是<code>OSM</code>格式的文件，需要转换成Shapfile才能用。比较简单的办法是下载一个QGIS，然后用QGIS导出为shapfile再用ARCGIS打开。</p><h3 id="STEP-2-创建网络数据集"><a href="#STEP-2-创建网络数据集" class="headerlink" title="STEP 2 创建网络数据集"></a>STEP 2 创建网络数据集</h3><p>准备好Shapfile以后，进入ARCGIS进行编辑，确保至少有阻抗信息字段，如距离或者行驶时间。如果是单向道路或者有转弯要素，可以参考这里配置相应字段：<a href="https://desktop.arcgis.com/zh-cn/arcmap/latest/extensions/network-analyst/types-of-evaluators-used-by-a-network.htm">https://desktop.arcgis.com/zh-cn/arcmap/latest/extensions/network-analyst/types-of-evaluators-used-by-a-network.htm</a></p><p>对于连通性的问题，可以启用菜单栏的拓扑工具来修改连通性。</p><p>准备好数据后，就可以创建网络数据集了。首先进入arccatalog启用网络分析拓展。</p><p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/04/03/5ca4c3853a213b0417a21a37.jpg"></p><p>然后在Shapfile上右键创建网络数据集</p><p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/04/03/5ca4c3da3a213b0417a21d27.jpg"></p><p>然后根据向导配置连通性，阻抗，方向等等各种属性就行了。最后点击完成就能创建一个网络数据集了。</p><h3 id="STEP3-进行网络分析"><a href="#STEP3-进行网络分析" class="headerlink" title="STEP3 进行网络分析"></a>STEP3 进行网络分析</h3><p>创建好网络数据集后，打开ARCMAP，打开arccatalog窗口，将网络数据集拖进来就能看到了。然后同上启用ARCMAP的网络分析拓展就可以开始分析了。</p><p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/04/03/5ca4c4ef3a213b0417a22582.jpg"></p><p>我们可以加载网络分析工具条，新建一个路径分析试试。打开工具条上的网络分析窗口按钮，选择停靠点，新建几个停靠点，在图层上右键选择求解：</p><p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/04/03/5ca4c5f03a213b0417a230d1.jpg"></p><p>可以看到，我们的网络分析成功了。查看路径属性表，可以看到，这条路径的长度是18566米</p><p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/superbed/2019/04/03/5ca4cb973a213b0417a25f2d.png"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://desktop.arcgis.com/zh-cn/arcmap/latest/extensions/network-analyst/exercise-1-creating-a-network-dataset.htm">https://desktop.arcgis.com/zh-cn/arcmap/latest/extensions/network-analyst/exercise-1-creating-a-network-dataset.htm</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;ArcGIS Network Analyst 扩展模块 可以解决一般的网络问题，例如查找穿过城市的最佳路线，查找最近的急救车辆或设施点，识别某一位置周围的服务区，使用一支车队为一组订单提供服务，或选择要设立或关闭的最佳设施点。</summary>
    
    
    
    
    <category term="GIS" scheme="https://coolrc.me/tags/GIS/"/>
    
  </entry>
  
  <entry>
    <title>用emoji规范Git commit message</title>
    <link href="https://coolrc.me/2019/02/18/201902181722/"/>
    <id>https://coolrc.me/2019/02/18/201902181722/</id>
    <published>2019-02-18T17:22:31.000Z</published>
    <updated>2019-02-18T17:22:31.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/19-02-18/snipaste_20190218_181705.png" alt="git commit emoji"><br><code>git commit</code>的时候不知道写什么？没关系，这里有一款工具解决你的烦恼。<code>commitizen</code>是一个自动生成<code>commit messsage</code>的工具，只需要运行<code>git cz</code>就能够自动根据你的选择帮你生成整洁美观的<code>commit messsage</code>。通常都是配合<code>conventional-changelog</code>使用<a href="https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines">angular的commit格式</a>。<br>这个技巧想必已经烂大街了。所以这里介绍一个更酷的方式：配合上一些第三方的配置文件，使用emoji来作为<code>commit messsage</code>。<span id="more"></span></p><h2 id="STEP-1-安装"><a href="#STEP-1-安装" class="headerlink" title="STEP 1 安装"></a>STEP 1 安装</h2><p>这里安装所需的工具：commitizen conventional-changelog conventional-changelog-cli cz-customizable，然后使用<a href="https://github.com/nielsgl/conventional-changelog-emoji">nielsgl/conventional-changelog-emoji</a>这个项目里面的配置文件自定义<code>commit messsage</code>格式。</p><p class="tip">其实用`cz-emoji`可以直接生成emoji格式的`commit message`的，但是这玩意生成的`commit message`用emoji取代了`<type>`，没法用`conventional-changelog-cli`生成`changelog`，所以我们要用`cz-customizable`进行自定义。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen conventional-changelog conventional-changelog-cli cz-customizable</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;path&quot;: &quot;cz-customizable&quot; &#125;&#x27;</span> &gt; ~/.czrc</span><br><span class="line">wget https://raw.githubusercontent.com/nielsgl/conventional-changelog-emoji/master/.cz-config.js -O ~/.cz-config.js</span><br></pre></td></tr></table></figure><h2 id="STEP-2-使用"><a href="#STEP-2-使用" class="headerlink" title="STEP 2 使用"></a>STEP 2 使用</h2><p>使用<code>git cz</code>就能按照选项填写 commit message。要生成<code>changelog</code>的话，参照如下方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不会覆盖以前的 Change log，只会在 CHANGELOG.md 的头部加上自从上次发布以来的变动</span></span><br><span class="line">$ conventional-changelog -i CHANGELOG.md -s -p </span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成所有发布的 Change log</span></span><br><span class="line">$ conventional-changelog -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><p>生成<code>changelog</code>后，要发布release什么的只要复制<code>CHANGELOG.md</code>的内容填进去就行了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://juejin.im/post/5bd2debfe51d457abc710b57">规范你的 commit message 并且根据 commit 自动生成 CHANGELOG.md</a><br><a href="https://github.com/commitizen/cz-cli">commitizen/cz-cli</a><br><a href="https://github.com/nielsgl/conventional-changelog-emoji">nielsgl/conventional-changelog-emoji</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://coolrc-blog.oss-cn-shenzhen.aliyuncs.com/19-02-18/snipaste_20190218_181705.png&quot; alt=&quot;git commit emoji&quot;&gt;&lt;br&gt;&lt;code&gt;git commit&lt;/code&gt;的时候不知道写什么？没关系，这里有一款工具解决你的烦恼。&lt;code&gt;commitizen&lt;/code&gt;是一个自动生成&lt;code&gt;commit messsage&lt;/code&gt;的工具，只需要运行&lt;code&gt;git cz&lt;/code&gt;就能够自动根据你的选择帮你生成整洁美观的&lt;code&gt;commit messsage&lt;/code&gt;。通常都是配合&lt;code&gt;conventional-changelog&lt;/code&gt;使用&lt;a href=&quot;https://github.com/angular/angular.js/blob/master/DEVELOPERS.md#-git-commit-guidelines&quot;&gt;angular的commit格式&lt;/a&gt;。&lt;br&gt;这个技巧想必已经烂大街了。所以这里介绍一个更酷的方式：配合上一些第三方的配置文件，使用emoji来作为&lt;code&gt;commit messsage&lt;/code&gt;。</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>travis-ci 部署到github release</title>
    <link href="https://coolrc.me/2019/02/08/201902081324/"/>
    <id>https://coolrc.me/2019/02/08/201902081324/</id>
    <published>2019-02-08T13:24:38.000Z</published>
    <updated>2019-02-08T13:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>更多内容看这里：<a href="https://docs.travis-ci.com/user/deployment/releases/">https://docs.travis-ci.com/user/deployment/releases/</a><span id="more"></span></p><h2 id="安装命令行工具"><a href="#安装命令行工具" class="headerlink" title="安装命令行工具"></a>安装命令行工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ruby ruby-dev</span><br><span class="line">gem install travis</span><br></pre></td></tr></table></figure><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">travis login --pro</span><br><span class="line">travis setup releases --pro</span><br></pre></td></tr></table></figure><h2 id="CI-配置"><a href="#CI-配置" class="headerlink" title="CI 配置"></a>CI 配置</h2><p>加入下面两行配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">name/repo</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>完整的<code>depoly</code>如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">provider:</span> <span class="string">releases</span></span><br><span class="line">  <span class="attr">api_key:</span></span><br><span class="line">    <span class="attr">secure:</span> <span class="string">BZy0B58PbjBxZpPEPxxt+JVV3x5MuM9Ca0q7uF3Z1PqWFEdoGgXQhWfHggEyd8EctEVCzr6MDFntAqsfFTG6mE9KJOlKOoUj4wkB1kTqUMNxWjR+5+8w8yAHHFwK9rQqgtpTtq3mL3euUox4UTzfliM2JWfGtkKJu0oKP2k6O0AbCV824506ZKe9cbTo0ato/DS8VizOcW7SXv3vupIjDW1EW5QziT7rReYjYf9o2quY0/muln80ennCHZn7uJxi4GS1rznN5R3iL1zfNXKzCUpwOTMTZbT2v6NLOHr1TCVINZofnnBMeQRoFt5GJcKRDZrlrSRENjFSd8q5p13TlB7pOOjwZnjwDXeqZ6famz41fZYtgxvXqgyie4iBrfXGSurCbdUW0vjgX3JOSMyG05PnZD+KUQUu3BKy77U38AK1E4Qbh1hmAfM2rv2qNJdpqlo7hvtb7QfUzXvlgXX0bzK7NyZp+MmZJ34wrHwe2KO/PuAvKivnBPGg9SLtZLr6wcyho+I1EvL+oDljEgcqMnxbiOlokJ0bN40YU4b9mSxNVGua41pDEFP5pyBsL9XYKMcAJJHnVKhQtNjLHagK+pn5/BtrVUt4HRM0OyID5s6YJFdTBhn1LG0TkiMeZda2t9OZwDoTBFQjwEcC2F99nxRcba4olBj/8kc6Q8wmTF0=</span></span><br><span class="line">  <span class="attr">file:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tgbot_linux_64</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tgbot_linux_32</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tgbot_windows_64.exe</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tgbot_windows_32.exe</span></span><br><span class="line">  <span class="attr">skip_cleanup:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">on:</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">coolrc136/go-tg-bot</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;更多内容看这里：&lt;a href=&quot;https://docs.travis-ci.com/user/deployment/releases/&quot;&gt;https://docs.travis-ci.com/user/deployment/releases/&lt;/a&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>golang逐行读取文件</title>
    <link href="https://coolrc.me/2018/11/08/201811081434/"/>
    <id>https://coolrc.me/2018/11/08/201811081434/</id>
    <published>2018-11-08T14:34:03.000Z</published>
    <updated>2018-11-08T14:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang 中读取文件有很多方法，本文介绍用<code>bufio</code>包如何逐行进行读取和写入。因为<code>bufio</code>包提供了缓冲，性能比较优秀。<span id="more"></span></p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="逐行存入切片"><a href="#逐行存入切片" class="headerlink" title="逐行存入切片"></a>逐行存入切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readLines</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">string</span>, <span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">  file, err := os.Open(path)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>,<span class="number">0</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> lines []<span class="keyword">string</span></span><br><span class="line">  linecount :=<span class="number">0</span></span><br><span class="line">  scanner := bufio.NewScanner(file)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    lines = <span class="built_in">append</span>(lines, scanner.Text())</span><br><span class="line">    linecount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lines,linecount,scanner.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>bufio</code>包的<code>scanner</code>可以对数据进行扫描输入，除了逐行分割以外，还有其他的分割方式：<br>ScanLines（默认）<br>ScanWords（分割单词）<br>ScanRunes（在遍历 UTF-8 字符串而不是字节时将会非常有用）<br>ScanBytes</p><h3 id="逐单词存入切片"><a href="#逐单词存入切片" class="headerlink" title="逐单词存入切片"></a>逐单词存入切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(<span class="string">&quot;filetoread.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">scanner := bufio.NewScanner(file)</span><br><span class="line">scanner.Split(bufio.ScanWords)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> words []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">    words = <span class="built_in">append</span>(words, scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;word list:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">    fmt.Println(word)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><p>写入使用的是<code>bufio</code>中<code>writer</code>对象的一些方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以下三个方法可以直接写入到文件中</span><br><span class="line"><span class="comment">//写入单个字节</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteByte</span><span class="params">(c <span class="keyword">byte</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//写入单个Unicode指针返回写入字节数和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteRune</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="params">(size <span class="keyword">int</span>, err error)</span></span></span><br><span class="line"><span class="comment">//写入字符串并返回写入字节数和错误信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Writer)</span> <span class="title">WriteString</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span></span><br></pre></td></tr></table></figure><h3 id="逐行写入"><a href="#逐行写入" class="headerlink" title="逐行写入"></a>逐行写入</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeLines</span><span class="params">(path <span class="keyword">string</span>, lines []<span class="keyword">string</span>)</span> <span class="title">error</span></span>&#123;</span><br><span class="line">    file, err := os.Create(path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line">    writer := bufio.NewWriter(file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,elem := <span class="keyword">range</span> lines &#123;</span><br><span class="line">        _,err = writer.WriteString(elem + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://xxbandy.github.io/2017/12/17/Golang%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/">Golang读写文件操作</a><br><a href="https://studygolang.com/articles/12905">使用 Go 读取文件 - 概览</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;golang 中读取文件有很多方法，本文介绍用&lt;code&gt;bufio&lt;/code&gt;包如何逐行进行读取和写入。因为&lt;code&gt;bufio&lt;/code&gt;包提供了缓冲，性能比较优秀。</summary>
    
    
    
    
    <category term="golang" scheme="https://coolrc.me/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>用gitlab自动部署博客</title>
    <link href="https://coolrc.me/2018/10/21/1810212220/"/>
    <id>https://coolrc.me/2018/10/21/1810212220/</id>
    <published>2018-10-21T22:20:07.000Z</published>
    <updated>2018-10-21T22:20:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然想用Windows写博客，但是要在windows上部署hexo还是挺麻烦的，就想着利用gitlab-CI的自动部署来帮我编译博客。<span id="more"></span></p><p>部署起来其实很简单，gitlab已经提供了各种博客系统的示例，当然也包括hexo，去这里<a href="https://gitlab.com/pages/hexo/tree/master">https://gitlab.com/pages/hexo/tree/master</a>把<code>.gitignore</code>和<code>.gitlab-ci.yml</code>这两个文件扒下来放博客目录里。在<code>.gitignore</code>最后一行加上<code>package-lock.json</code>。</p><p>然后修改<code>.gitlab-ci.yml</code>文件，<code>pages</code>前面加上一个代码块</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">export</span> <span class="string">TZ=&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;你的id&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">hexo-cli</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br></pre></td></tr></table></figure><p>然后去github申请一个有repo权限的token，&gt;&gt; <a href="https://github.com/settings/tokens">传送门</a></p><p>修改hexo的配置文件的repo为</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">     <span class="attr">github:</span> <span class="string">https://你的token:x-oauth-basic@github.com/coolrc136/coolrc136.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>然后把git仓库push上去就行，gitlab就会自动帮你部署啦</p><p>hexo的配置文件中一般都存了很多token，安全起见，建议保存到私有仓库。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天突然想用Windows写博客，但是要在windows上部署hexo还是挺麻烦的，就想着利用gitlab-CI的自动部署来帮我编译博客。</summary>
    
    
    
    
    <category term="git" scheme="https://coolrc.me/tags/git/"/>
    
    <category term="hexo" scheme="https://coolrc.me/tags/hexo/"/>
    
    <category term="blog" scheme="https://coolrc.me/tags/blog/"/>
    
  </entry>
  
</feed>
